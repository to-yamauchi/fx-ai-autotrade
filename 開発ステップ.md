# FX自動トレードシステム 開発ステップ

## 概要
このドキュメントでは、FX自動トレードシステムの開発手順を段階的に説明します。
システムは6つのフェーズに分けて開発し、各フェーズで動作確認を行いながら進めます。

---

## フェーズ1: 環境構築とデータ基盤

### ステップ1.1: 開発環境のセットアップ
**目的**: 開発に必要な環境とツールを準備する

**作業内容**:
1. Pythonプロジェクトの初期化
   - Python 3.11以上のインストール確認
   - 仮想環境の作成: `python -m venv venv`
   - 依存パッケージのインストール: `pip install -r requirements.txt`

2. 必要なライブラリのインストール
   ```
   pandas>=2.0.0
   numpy>=1.24.0
   MetaTrader5>=5.0.45
   psycopg2-binary>=2.9.0
   google-generativeai>=0.3.0
   python-dotenv>=1.0.0
   pytest>=7.4.0
   ```

3. ディレクトリ構造の作成
   ```
   fx-ai-autotrade/
   ├── src/
   │   ├── data_processing/
   │   ├── ai_analysis/
   │   ├── rule_engine/
   │   ├── trade_execution/
   │   ├── monitoring/
   │   └── utils/
   ├── tests/
   ├── data/
   │   └── tick_data/USDJPY/
   ├── config/
   └── logs/
   ```

4. 環境変数ファイルの作成
   ```
   # .env
   GEMINI_API_KEY=your_api_key_here
   MT5_LOGIN=your_mt5_login
   MT5_PASSWORD=your_mt5_password
   MT5_SERVER=your_mt5_server
   DB_HOST=localhost
   DB_PORT=5432
   DB_NAME=fx_autotrade
   DB_USER=postgres
   DB_PASSWORD=your_password
   ```

**検証方法**:
- `python --version`で3.11以上を確認
- `pip list`で全パッケージがインストール済みを確認
- ディレクトリ構造が正しく作成されているか確認

---

### ステップ1.2: データベースのセットアップ
**目的**: PostgreSQLデータベースとテーブルを構築する

**作業内容**:
1. PostgreSQLのインストールと起動
   - PostgreSQL 14以上をインストール
   - データベース `fx_autotrade` を作成

2. テーブルの作成
   ```sql
   -- ティックデータテーブル
   CREATE TABLE tick_data (
       id BIGSERIAL PRIMARY KEY,
       symbol VARCHAR(10) NOT NULL,
       timestamp TIMESTAMP NOT NULL,
       bid DECIMAL(10, 5) NOT NULL,
       ask DECIMAL(10, 5) NOT NULL,
       volume INTEGER,
       UNIQUE(symbol, timestamp)
   );
   CREATE INDEX idx_tick_timestamp ON tick_data(timestamp);

   -- 時間足データテーブル
   CREATE TABLE timeframe_data (
       id BIGSERIAL PRIMARY KEY,
       symbol VARCHAR(10) NOT NULL,
       timeframe VARCHAR(5) NOT NULL,
       timestamp TIMESTAMP NOT NULL,
       open DECIMAL(10, 5) NOT NULL,
       high DECIMAL(10, 5) NOT NULL,
       low DECIMAL(10, 5) NOT NULL,
       close DECIMAL(10, 5) NOT NULL,
       volume INTEGER,
       UNIQUE(symbol, timeframe, timestamp)
   );
   CREATE INDEX idx_timeframe_timestamp ON timeframe_data(symbol, timeframe, timestamp);

   -- AIトレード判断テーブル
   CREATE TABLE ai_judgments (
       id BIGSERIAL PRIMARY KEY,
       timestamp TIMESTAMP NOT NULL,
       symbol VARCHAR(10) NOT NULL,
       action VARCHAR(10) NOT NULL,
       confidence DECIMAL(5, 2),
       reasoning TEXT,
       market_data JSONB,
       created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
   );

   -- ポジションテーブル
   CREATE TABLE positions (
       id BIGSERIAL PRIMARY KEY,
       ticket BIGINT UNIQUE,
       symbol VARCHAR(10) NOT NULL,
       type VARCHAR(10) NOT NULL,
       volume DECIMAL(10, 2) NOT NULL,
       open_price DECIMAL(10, 5) NOT NULL,
       sl DECIMAL(10, 5),
       tp DECIMAL(10, 5),
       open_time TIMESTAMP NOT NULL,
       close_time TIMESTAMP,
       close_price DECIMAL(10, 5),
       profit DECIMAL(10, 2),
       status VARCHAR(20) NOT NULL
   );

   -- バックテスト結果テーブル
   CREATE TABLE backtest_results (
       id BIGSERIAL PRIMARY KEY,
       test_name VARCHAR(100) NOT NULL,
       start_date DATE NOT NULL,
       end_date DATE NOT NULL,
       total_trades INTEGER,
       win_rate DECIMAL(5, 2),
       direction_accuracy DECIMAL(5, 2),
       judgment_consistency DECIMAL(5, 2),
       profit_factor DECIMAL(10, 2),
       max_drawdown DECIMAL(10, 2),
       created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
   );
   ```

**検証方法**:
- `psql -U postgres -d fx_autotrade -c "\dt"`でテーブル一覧を確認
- 各テーブルに対して`SELECT * FROM table_name LIMIT 1;`を実行

---

### ステップ1.3: zipファイルからのティックデータ読み込み
**目的**: 月次zipファイルからティックデータを読み込む機能を実装する

**作業内容**:
1. `src/data_processing/tick_loader.py`を作成
   ```python
   import zipfile
   import csv
   import io
   from datetime import datetime
   from typing import List, Dict
   import logging

   class TickDataLoader:
       """zipファイルからティックデータを読み込むクラス"""

       def __init__(self, data_dir: str = "data/tick_data"):
           self.data_dir = data_dir
           self.logger = logging.getLogger(__name__)

       def load_from_zip(self, symbol: str, year: int, month: int) -> List[Dict]:
           """
           zipファイルからティックデータを読み込む

           Args:
               symbol: 通貨ペア (例: USDJPY)
               year: 年 (例: 2024)
               month: 月 (例: 9)

           Returns:
               ティックデータのリスト
           """
           # ファイル名: ticks_USDJPY-oj5k_2024-09.zip
           zip_filename = f"ticks_{symbol}-oj5k_{year:04d}-{month:02d}.zip"
           zip_path = f"{self.data_dir}/{symbol}/{zip_filename}"

           tick_data = []

           try:
               with zipfile.ZipFile(zip_path, 'r') as zip_ref:
                   # CSV名: ticks_USDJPY-oj5k_2024-09.csv
                   csv_filename = f"ticks_{symbol}-oj5k_{year:04d}-{month:02d}.csv"

                   with zip_ref.open(csv_filename) as f:
                       reader = csv.DictReader(io.TextIOWrapper(f, 'utf-8'))

                       for row in reader:
                           tick = {
                               'timestamp': datetime.fromisoformat(row['timestamp']),
                               'bid': float(row['bid']),
                               'ask': float(row['ask']),
                               'volume': int(row.get('volume', 0))
                           }
                           tick_data.append(tick)

               self.logger.info(f"Loaded {len(tick_data)} ticks from {zip_filename}")
               return tick_data

           except FileNotFoundError:
               self.logger.error(f"File not found: {zip_path}")
               raise
           except Exception as e:
               self.logger.error(f"Error loading tick data: {e}")
               raise
   ```

2. テストデータの準備
   - `data/tick_data/USDJPY/`にサンプルzipファイルを配置
   - フォーマット: `ticks_USDJPY-oj5k_2024-09.zip`

3. ユニットテストの作成
   ```python
   # tests/test_tick_loader.py
   import pytest
   from src.data_processing.tick_loader import TickDataLoader

   def test_load_from_zip():
       loader = TickDataLoader()
       data = loader.load_from_zip("USDJPY", 2024, 9)

       assert len(data) > 0
       assert 'timestamp' in data[0]
       assert 'bid' in data[0]
       assert 'ask' in data[0]
   ```

**検証方法**:
- `pytest tests/test_tick_loader.py -v`でテスト実行
- サンプルデータが正しく読み込まれることを確認

---

## フェーズ2: データ変換とテクニカル指標計算

### ステップ2.1: 時間足変換の実装
**目的**: ティックデータからD1/H4/H1/M15の時間足データを生成する

**作業内容**:
1. `src/data_processing/timeframe_converter.py`を作成
   ```python
   import pandas as pd
   from typing import List, Dict
   from datetime import datetime, timedelta

   class TimeframeConverter:
       """ティックデータを時間足データに変換するクラス"""

       TIMEFRAMES = {
           'D1': timedelta(days=1),
           'H4': timedelta(hours=4),
           'H1': timedelta(hours=1),
           'M15': timedelta(minutes=15)
       }

       def convert(self, tick_data: List[Dict], timeframe: str) -> pd.DataFrame:
           """
           ティックデータを指定した時間足に変換

           Args:
               tick_data: ティックデータのリスト
               timeframe: 時間足 (D1/H4/H1/M15)

           Returns:
               OHLCV形式のDataFrame
           """
           if timeframe not in self.TIMEFRAMES:
               raise ValueError(f"Invalid timeframe: {timeframe}")

           # DataFrameに変換
           df = pd.DataFrame(tick_data)
           df['timestamp'] = pd.to_datetime(df['timestamp'])
           df['mid'] = (df['bid'] + df['ask']) / 2

           # リサンプリング周期を決定
           resample_rule = self._get_resample_rule(timeframe)

           # OHLCV形式に変換
           ohlcv = df.set_index('timestamp').resample(resample_rule).agg({
               'mid': ['first', 'max', 'min', 'last'],
               'volume': 'sum'
           })

           ohlcv.columns = ['open', 'high', 'low', 'close', 'volume']
           ohlcv = ohlcv.dropna()

           return ohlcv

       def _get_resample_rule(self, timeframe: str) -> str:
           """pandas resampleルールを取得"""
           rules = {
               'D1': 'D',
               'H4': '4H',
               'H1': '1H',
               'M15': '15T'
           }
           return rules[timeframe]
   ```

**検証方法**:
- 各時間足でOHLCVデータが正しく生成されるか確認
- データの連続性と欠損がないか確認

---

### ステップ2.2: テクニカル指標の計算
**目的**: EMA、RSI、MACD、ATR、ボリンジャーバンドを計算する

**作業内容**:
1. `src/data_processing/technical_indicators.py`を作成
   ```python
   import pandas as pd
   import numpy as np

   class TechnicalIndicators:
       """テクニカル指標を計算するクラス"""

       @staticmethod
       def calculate_ema(data: pd.Series, period: int) -> pd.Series:
           """EMA (指数移動平均) を計算"""
           return data.ewm(span=period, adjust=False).mean()

       @staticmethod
       def calculate_rsi(data: pd.Series, period: int = 14) -> pd.Series:
           """RSI (相対力指数) を計算"""
           delta = data.diff()
           gain = (delta.where(delta > 0, 0)).rolling(window=period).mean()
           loss = (-delta.where(delta < 0, 0)).rolling(window=period).mean()
           rs = gain / loss
           rsi = 100 - (100 / (1 + rs))
           return rsi

       @staticmethod
       def calculate_macd(data: pd.Series,
                         fast: int = 12,
                         slow: int = 26,
                         signal: int = 9) -> Dict[str, pd.Series]:
           """MACD を計算"""
           ema_fast = data.ewm(span=fast, adjust=False).mean()
           ema_slow = data.ewm(span=slow, adjust=False).mean()
           macd_line = ema_fast - ema_slow
           signal_line = macd_line.ewm(span=signal, adjust=False).mean()
           histogram = macd_line - signal_line

           return {
               'macd': macd_line,
               'signal': signal_line,
               'histogram': histogram
           }

       @staticmethod
       def calculate_atr(high: pd.Series,
                        low: pd.Series,
                        close: pd.Series,
                        period: int = 14) -> pd.Series:
           """ATR (平均真の範囲) を計算"""
           tr1 = high - low
           tr2 = abs(high - close.shift())
           tr3 = abs(low - close.shift())
           tr = pd.concat([tr1, tr2, tr3], axis=1).max(axis=1)
           atr = tr.rolling(window=period).mean()
           return atr

       @staticmethod
       def calculate_bollinger_bands(data: pd.Series,
                                    period: int = 20,
                                    std_dev: float = 2.0) -> Dict[str, pd.Series]:
           """ボリンジャーバンドを計算"""
           sma = data.rolling(window=period).mean()
           std = data.rolling(window=period).std()

           return {
               'upper': sma + (std * std_dev),
               'middle': sma,
               'lower': sma - (std * std_dev)
           }

       @staticmethod
       def calculate_support_resistance(data: pd.DataFrame,
                                       window: int = 20) -> Dict[str, float]:
           """サポート・レジスタンスレベルを計算"""
           recent_data = data.tail(window)

           return {
               'resistance': recent_data['high'].max(),
               'support': recent_data['low'].min()
           }
   ```

**検証方法**:
- 各指標の計算結果が妥当な範囲内か確認
- 既知のデータで期待値と比較

---

### ステップ2.3: データ標準化とJSON変換
**目的**: AI用にデータを標準化し、JSON形式に変換する

**作業内容**:
1. `src/data_processing/data_standardizer.py`を作成
   ```python
   import json
   from typing import Dict, List
   import pandas as pd

   class DataStandardizer:
       """AIが判断しやすい形式にデータを標準化するクラス"""

       def standardize_for_ai(self,
                             timeframe_data: Dict[str, pd.DataFrame],
                             indicators: Dict[str, any]) -> Dict:
           """
           マーケットデータをAI用に標準化

           Args:
               timeframe_data: 各時間足のOHLCVデータ
               indicators: テクニカル指標

           Returns:
               標準化されたJSONデータ
           """
           standardized = {
               'timestamp': pd.Timestamp.now().isoformat(),
               'timeframes': {},
               'technical_indicators': {},
               'market_conditions': {}
           }

           # 時間足データを標準化
           for tf, df in timeframe_data.items():
               latest = df.iloc[-1]
               prev = df.iloc[-2] if len(df) > 1 else latest

               standardized['timeframes'][tf] = {
                   'current': {
                       'open': float(latest['open']),
                       'high': float(latest['high']),
                       'low': float(latest['low']),
                       'close': float(latest['close']),
                       'volume': int(latest['volume'])
                   },
                   'change_pct': float((latest['close'] - prev['close']) / prev['close'] * 100)
               }

           # テクニカル指標を標準化
           standardized['technical_indicators'] = {
               'ema': {
                   'short': float(indicators['ema_short'].iloc[-1]),
                   'long': float(indicators['ema_long'].iloc[-1]),
                   'trend': 'up' if indicators['ema_short'].iloc[-1] > indicators['ema_long'].iloc[-1] else 'down'
               },
               'rsi': {
                   'value': float(indicators['rsi'].iloc[-1]),
                   'condition': self._classify_rsi(indicators['rsi'].iloc[-1])
               },
               'macd': {
                   'macd': float(indicators['macd']['macd'].iloc[-1]),
                   'signal': float(indicators['macd']['signal'].iloc[-1]),
                   'histogram': float(indicators['macd']['histogram'].iloc[-1]),
                   'trend': 'bullish' if indicators['macd']['histogram'].iloc[-1] > 0 else 'bearish'
               },
               'bollinger': {
                   'upper': float(indicators['bollinger']['upper'].iloc[-1]),
                   'middle': float(indicators['bollinger']['middle'].iloc[-1]),
                   'lower': float(indicators['bollinger']['lower'].iloc[-1]),
                   'position': self._classify_bb_position(
                       latest['close'],
                       indicators['bollinger']
                   )
               }
           }

           # マーケット状況を分析
           standardized['market_conditions'] = {
               'volatility': self._calculate_volatility(indicators['atr']),
               'trend_strength': self._calculate_trend_strength(indicators),
               'support_resistance': indicators['support_resistance']
           }

           return standardized

       def _classify_rsi(self, rsi_value: float) -> str:
           """RSIを分類"""
           if rsi_value >= 70:
               return 'overbought'
           elif rsi_value <= 30:
               return 'oversold'
           else:
               return 'neutral'

       def _classify_bb_position(self, price: float, bb: Dict) -> str:
           """ボリンジャーバンド内の位置を分類"""
           upper = bb['upper'].iloc[-1]
           lower = bb['lower'].iloc[-1]
           middle = bb['middle'].iloc[-1]

           if price >= upper:
               return 'above_upper'
           elif price <= lower:
               return 'below_lower'
           elif price > middle:
               return 'upper_half'
           else:
               return 'lower_half'

       def _calculate_volatility(self, atr: pd.Series) -> str:
           """ボラティリティを分類"""
           current_atr = atr.iloc[-1]
           avg_atr = atr.mean()

           if current_atr > avg_atr * 1.5:
               return 'high'
           elif current_atr < avg_atr * 0.5:
               return 'low'
           else:
               return 'normal'

       def _calculate_trend_strength(self, indicators: Dict) -> str:
           """トレンド強度を計算"""
           # EMAとMACDから総合判断
           ema_trend = 1 if indicators['ema_short'].iloc[-1] > indicators['ema_long'].iloc[-1] else -1
           macd_trend = 1 if indicators['macd']['histogram'].iloc[-1] > 0 else -1

           if ema_trend == macd_trend:
               return 'strong'
           else:
               return 'weak'
   ```

**検証方法**:
- JSON出力が正しい構造か確認
- 各フィールドの値が妥当か確認

---

## フェーズ3: AI分析エンジンの実装

### ステップ3.1: Gemini API連携
**目的**: Gemini APIと連携し、マーケットデータを分析する

**作業内容**:
1. `src/ai_analysis/gemini_client.py`を作成
   ```python
   import google.generativeai as genai
   from typing import Dict, Optional
   import os
   import logging

   class GeminiClient:
       """Gemini APIクライアント"""

       def __init__(self):
           self.api_key = os.getenv('GEMINI_API_KEY')
           genai.configure(api_key=self.api_key)
           self.logger = logging.getLogger(__name__)

           # モデルの初期化
           self.model_pro = genai.GenerativeModel('gemini-1.5-pro-latest')
           self.model_flash = genai.GenerativeModel('gemini-1.5-flash-latest')
           self.model_flash_lite = genai.GenerativeModel('gemini-1.5-flash-8b-latest')

       def analyze_market(self,
                         market_data: Dict,
                         model: str = 'flash') -> Dict:
           """
           マーケットデータを分析

           Args:
               market_data: 標準化されたマーケットデータ
               model: 使用するモデル (pro/flash/flash-lite)

           Returns:
               AI判断結果
           """
           # プロンプトの構築
           prompt = self._build_analysis_prompt(market_data)

           # モデルの選択
           selected_model = self._select_model(model)

           try:
               # AI分析の実行
               response = selected_model.generate_content(prompt)

               # レスポンスのパース
               result = self._parse_response(response.text)

               self.logger.info(f"AI Analysis: {result['action']} (confidence: {result['confidence']}%)")
               return result

           except Exception as e:
               self.logger.error(f"AI analysis error: {e}")
               return {
                   'action': 'HOLD',
                   'confidence': 0,
                   'reasoning': f'Error: {str(e)}'
               }

       def _build_analysis_prompt(self, market_data: Dict) -> str:
           """分析プロンプトを構築"""
           prompt = f"""
あなたはプロのFXトレーダーです。以下のマーケットデータを分析し、トレード判断を行ってください。

## マーケットデータ
{json.dumps(market_data, indent=2, ensure_ascii=False)}

## 分析指示
1. 各時間足のトレンドを分析してください
2. テクニカル指標から相場の状態を判断してください
3. サポート・レジスタンスレベルを考慮してください
4. 総合的な判断として、BUY/SELL/HOLDのいずれかを選択してください

## 出力フォーマット
以下のJSON形式で回答してください:
{{
  "action": "BUY/SELL/HOLD",
  "confidence": 0-100の数値,
  "reasoning": "判断理由を詳しく説明",
  "entry_price": エントリー推奨価格 (actionがHOLD以外の場合),
  "stop_loss": ストップロス推奨価格,
  "take_profit": テイクプロフィット推奨価格
}}
"""
           return prompt

       def _select_model(self, model: str):
           """モデルを選択"""
           models = {
               'pro': self.model_pro,
               'flash': self.model_flash,
               'flash-lite': self.model_flash_lite
           }
           return models.get(model, self.model_flash)

       def _parse_response(self, response_text: str) -> Dict:
           """AIレスポンスをパース"""
           import re
           import json

           # JSONブロックを抽出
           json_match = re.search(r'```json\s*(\{.*?\})\s*```', response_text, re.DOTALL)
           if json_match:
               json_text = json_match.group(1)
           else:
               # JSONブロックがない場合、全体をJSONとしてパース試行
               json_text = response_text

           try:
               result = json.loads(json_text)
               return result
           except json.JSONDecodeError:
               # パース失敗時はデフォルト値を返す
               return {
                   'action': 'HOLD',
                   'confidence': 0,
                   'reasoning': 'Failed to parse AI response'
               }
   ```

**検証方法**:
- テストデータでGemini APIを呼び出し、正しい応答が返るか確認
- 各モデル(pro/flash/flash-lite)で動作確認

---

### ステップ3.2: AI判断ロジックの実装
**目的**: AI判断を実行し、結果をDBに保存する

**作業内容**:
1. `src/ai_analysis/ai_analyzer.py`を作成
2. 定期実行とイベントドリブンの両方に対応
3. 判断結果をDBに保存する機能を実装

**検証方法**:
- AI判断が正しく実行されるか確認
- DBに判断結果が保存されるか確認

---

## フェーズ4: ルールエンジンとトレード実行

### ステップ4.1: ルールエンジンの実装
**目的**: AI判断に基づいてトレードルールを適用する

**作業内容**:
1. `src/rule_engine/trading_rules.py`を作成
   ```python
   class TradingRules:
       """トレードルールを管理するクラス"""

       MIN_CONFIDENCE = 60  # 最小信頼度
       MAX_SPREAD = 3.0     # 最大スプレッド(pips)
       MAX_POSITIONS = 3    # 最大同時ポジション数

       def validate_trade(self,
                         ai_judgment: Dict,
                         current_positions: int,
                         spread: float) -> bool:
           """
           トレード実行可否を判定

           Returns:
               True: 実行可能, False: 実行不可
           """
           # 信頼度チェック
           if ai_judgment['confidence'] < self.MIN_CONFIDENCE:
               return False

           # スプレッドチェック
           if spread > self.MAX_SPREAD:
               return False

           # ポジション数チェック
           if current_positions >= self.MAX_POSITIONS:
               return False

           # HOLDの場合は実行しない
           if ai_judgment['action'] == 'HOLD':
               return False

           return True
   ```

**検証方法**:
- 各ルールが正しく適用されるか確認

---

### ステップ4.2: MT5トレード実行
**目的**: MetaTrader5経由でトレードを実行する

**作業内容**:
1. `src/trade_execution/mt5_executor.py`を作成
   ```python
   import MetaTrader5 as mt5
   from typing import Optional, Dict
   import logging

   class MT5Executor:
       """MT5でトレードを実行するクラス"""

       def __init__(self):
           self.logger = logging.getLogger(__name__)
           self.initialize_mt5()

       def initialize_mt5(self):
           """MT5を初期化"""
           if not mt5.initialize():
               self.logger.error("MT5 initialization failed")
               raise Exception("Failed to initialize MT5")

           # ログイン
           login = int(os.getenv('MT5_LOGIN'))
           password = os.getenv('MT5_PASSWORD')
           server = os.getenv('MT5_SERVER')

           if not mt5.login(login, password, server):
               self.logger.error("MT5 login failed")
               raise Exception("Failed to login to MT5")

       def execute_trade(self,
                        symbol: str,
                        action: str,
                        volume: float,
                        sl: Optional[float] = None,
                        tp: Optional[float] = None) -> Optional[int]:
           """
           トレードを実行

           Returns:
               成功時: ticket番号, 失敗時: None
           """
           # 注文タイプを決定
           order_type = mt5.ORDER_TYPE_BUY if action == 'BUY' else mt5.ORDER_TYPE_SELL

           # 現在価格を取得
           tick = mt5.symbol_info_tick(symbol)
           price = tick.ask if action == 'BUY' else tick.bid

           # 注文リクエストを作成
           request = {
               "action": mt5.TRADE_ACTION_DEAL,
               "symbol": symbol,
               "volume": volume,
               "type": order_type,
               "price": price,
               "sl": sl,
               "tp": tp,
               "deviation": 10,
               "magic": 234000,
               "comment": "AI Trade",
               "type_time": mt5.ORDER_TIME_GTC,
               "type_filling": mt5.ORDER_FILLING_IOC,
           }

           # 注文を送信
           result = mt5.order_send(request)

           if result.retcode == mt5.TRADE_RETCODE_DONE:
               self.logger.info(f"Trade executed: {action} {volume} {symbol} @ {price}")
               return result.order
           else:
               self.logger.error(f"Trade failed: {result.comment}")
               return None
   ```

**検証方法**:
- デモ口座でトレード実行をテスト
- ポジションが正しく開かれるか確認

---

## フェーズ5: モニタリングと決済システム

### ステップ5.1: 3層モニタリングシステム
**目的**: Layer1/Layer2/Layer3のモニタリングを実装する

**作業内容**:
1. `src/monitoring/position_monitor.py`を作成
   - Layer1: 緊急決済 (損失15%、利益50%)
   - Layer2: 異常検知 (DD10%、逆行8%)
   - Layer3: AI再評価 (定期的な判断見直し)

**検証方法**:
- 各レイヤーのアラートが正しく発動するか確認

---

### ステップ5.2: 自動決済機能
**目的**: 条件に応じて自動的にポジションを決済する

**作業内容**:
1. 決済ロジックの実装
2. MT5経由での決済実行

**検証方法**:
- 各条件で決済が正しく実行されるか確認

---

## フェーズ6: バックテストシステム

### ステップ6.1: バックテストエンジン
**目的**: 過去データでAI判断精度を検証する

**作業内容**:
1. `src/backtest/backtest_engine.py`を作成
   ```python
   class BacktestEngine:
       """バックテストエンジン"""

       def run_backtest(self,
                       start_date: str,
                       end_date: str,
                       symbol: str = 'USDJPY') -> Dict:
           """
           バックテストを実行

           目的:
           - AI判断精度の検証 (方向性60%以上)
           - 判断の一貫性確認 (85%以上)
           - パフォーマンス分析
           """
           results = {
               'total_trades': 0,
               'correct_direction': 0,
               'direction_accuracy': 0.0,
               'judgment_consistency': 0.0,
               'trades': []
           }

           # 期間内の全データを処理
           # (実装詳細)

           return results
   ```

**検証方法**:
- 過去1ヶ月分のデータでバックテスト実行
- 方向性精度が計算されるか確認
- 判断の一貫性が評価されるか確認

---

### ステップ6.2: バックテスト結果分析
**目的**: バックテスト結果を分析し、AI性能を評価する

**作業内容**:
1. 結果のレポート生成
2. 判断精度の可視化
3. 改善点の洗い出し

**検証方法**:
- レポートが正しく生成されるか確認
- 精度指標が妥当か確認

---

## 各フェーズの完了基準

### フェーズ1完了基準
- [ ] 全依存パッケージがインストール済み
- [ ] データベーステーブルが作成済み
- [ ] zipファイルからティックデータを読み込める
- [ ] ユニットテストがすべてパス

### フェーズ2完了基準
- [ ] 全時間足(D1/H4/H1/M15)の変換が動作
- [ ] 全テクニカル指標が正しく計算される
- [ ] AI用JSON形式への変換が動作
- [ ] データ品質チェックをパス

### フェーズ3完了基準
- [ ] Gemini API連携が動作
- [ ] AI判断が正しく実行される
- [ ] 判断結果がDBに保存される
- [ ] エラーハンドリングが実装済み

### フェーズ4完了基準
- [ ] ルールエンジンが全ルールを適用
- [ ] MT5経由でトレード実行可能
- [ ] デモ口座でトレード成功
- [ ] ポジション管理が動作

### フェーズ5完了基準
- [ ] 3層モニタリングが動作
- [ ] 自動決済が正しく実行される
- [ ] アラート通知が動作
- [ ] ログが適切に記録される

### フェーズ6完了基準
- [ ] バックテストが実行可能
- [ ] 判断精度が計算される
- [ ] 一貫性評価が動作
- [ ] 結果レポートが生成される

---

## 開発の注意事項

### コーディング規約
- PEP 8に準拠
- 型ヒントを使用
- Docstringを必ず記述
- ロギングを適切に実装

### テスト方針
- ユニットテストを必ず作成
- カバレッジ80%以上を目標
- 統合テストも実施

### エラーハンドリング
- 例外は適切にキャッチ
- ログに詳細を記録
- ユーザーフレンドリーなメッセージ

### セキュリティ
- API キーは環境変数で管理
- 秘密情報をコードに含めない
- .envファイルは.gitignoreに追加

---

## 次のステップ

このドキュメントに従って開発を進めてください。各フェーズを順番に完了させ、完了基準を満たしてから次のフェーズに進むことをお勧めします。

質問や不明点があれば、各仕様書を参照してください:
- FX自動トレード仕様書.md
- docs/architecture/ 配下の各種仕様書
- docs/basic_design/ 配下の設計書
